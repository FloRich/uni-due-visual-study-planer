<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Compare Subjects</title>
    <link rel="stylesheet" href="compare-page.css"/>
    <link rel="stylesheet" href="../scripts/bootstrap/bootstrap.min.css"/>
    <script src="../scripts/app-local-storage.js"></script>
    <script type="text/javascript" src="compare-page.js"></script>
    <script src="../data/subject_ratings.js"></script>
    <script src="../scripts/d3.js"></script>
</head>
<body>
    <main>
        <svg id="heatmaps">
            <defs>
                <pattern id="no_rating" x="0" y="0"  width="50" height="50">
                    <line x1="7" x2="18" y1="7" y2="18" class="cross-line"></line>
                    <line x1="18" x2="7" y1="7" y2="18" class="cross-line"></line>
                </pattern>
            </defs>
            <g id="move-group">
                <g id="rating-map">
                </g>
                <g id="timeoverlap-matrix">
                </g>
            </g>
        </svg>
    </main>
    <nav id="side-menu">
        <div class="card">
            <div class="card-header">
                <h2>
                    Step 2: Compare
                </h2>
                <h4> Decide which subjects you want to take </h4>
            </div>
            <div class="card-body">
                <section id="sws">
                    <div id="amount_of_sws">
                    </div>
                </section>
                <div id="sws-legend">
                    <span>Legend:</span>
                    <div id="sws-legend-items">

                    </div>
                </div>
                <br/>
                <section id="removed_subjects">
                    <h6>Removed Subjects</h6>
                    <hr/>
                    <ul id="subject-selection">
                    </ul>
                </section>
            </div>
        </div>
    </nav>

    <script>

        setSvgHightToParentsWidth();

        // save ratings by the subjects name
        let subjects_dict = new Map();
        for (let subject of subjects) {
            subjects_dict.set(subject.name, subject);
        }

        // add ratings to the subject if it exists.
        for (let sub of selected_subjects) {
            let rating = subjects_dict.get(sub.name);
            if (rating !== undefined) {
                sub['rating'] = rating;
            } else {
                sub['rating'] = {};
            }
        }

        // Labels of row and columns
        let myGroups = ['recommendation', 'understandability', 'fairness','support','material','interest','fun', 'node_effort'];
        let width_of_field = 25;
        let height_of_field = 25;
        let width_of_legend = 100;

        // set the dimensions and margins of the rating-map
        var margin = {top: 300, right: 30, bottom: 30, left: 500},
          width = width_of_field * myGroups.length,
          height = height_of_field * selected_subjects.length;

        // append the svg object to the body of the page
        var svg = d3.select("#rating-map")
          .attr("width", width + margin.left + width_of_legend)
          .attr("height", height + margin.top + margin.bottom)
            .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Build color scale
        var ratingColorScale = d3.scaleLinear()
            .range(["#fffc85", "#4bb354"])
            .domain([0,100]);

        var linearGradient = svg.append("defs")
            .append("linearGradient")
            .attr("id", "linear-gradient");

        linearGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", ratingColorScale(0));

        linearGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", ratingColorScale(100));

        svg = svg.data(selected_subjects);

        // Build X scales and axis:
        var x = d3.scaleBand()
          .range([ 0, width ])
          .domain(myGroups)
          .padding(0.01);


        svg.append("g")
          .attr("transform","rotate(0)", "translate(0," + height + ")")
          .call(d3.axisTop(x))
          .selectAll("text")
          .attr("y", 0)
          .attr("x", 5)
          .attr("dy", -5)
          .attr("transform", "rotate(-45)")
          .style("text-anchor", "start");

        // Construct legend
        let legend = svg.append("g")
            .attr("class","legend-content")
            .attr("transform","translate("+0+","+ (height+30)+")");

        // Create scale"
        let legendScale = legend.append("g");
        legendScale.append("text")
            .attr("transform","translate(-30,12.5)")
            .style("font-size","15px")
            .text("0 %");
        legendScale.append("rect")
            .attr("x", 0)
            .attr("y",0)
            .attr("width", width)
            .attr("height", 15)
            .attr("fill", "url(#linear-gradient)");
        legendScale.append("text")
            .attr("transform", "translate("+(width+5)+",12.5)")
            .style("font-size","15px")
            .text("100 %");

        // Add explaination for X
        let legendNoRating = legend.append("g")
            .attr("class","x-explaination")
            .attr("transform","translate(0,+"+40+")");
        legendNoRating.append("rect")
            .attr("y",-(width_of_field*0.7))
            .attr("transform","scale(0.7)")
            .attr("width", width_of_field)
            .attr("height",height_of_field)
            .attr("fill", "url(#no_rating)");
        legendNoRating.append("text")
            .style("font-size","15px")
            .attr("x", width_of_field * 0.7)
            .attr("y", 1)
            .text("No Rating");

        //Create triangle
        var symbolGenerator = d3.symbol()
            .type(d3.symbolTriangle)
            .size(64);

        var triangle = legend.append("g")
            .attr("transform","rotate(180), translate("+(-width/2)+",5)")
            .attr("class", "triangle-pointer");

        triangle
            .append("path")
            .attr("d", symbolGenerator());

        triangle
            .append("text")
            .attr("transform","rotate(180)")
            .attr("x",0)
            .style("text-anchor","middle")
            .attr("id","triangle-text")
            .style("font-size","10px")
            .attr("y",30)
            .text("");

        /**
         * Moves the triangle from the legend to the specified element and position
         * @param type the element to move on. One of "values", "x-explaination"
         * @param value
         */
        function moveTriangeToValue(type, value) {
            let x = -3;
            let y = 5;
            if (type === "values") {
                x = x +value * (width);

                d3.select("#triangle-text").transition().delay(300).text(Math.round(value*10000)/100+" %");

                triangle
                    .transition()
                    .delay(300)
                    .attr("transform", "rotate(180) translate("+-x+","+y+")")
            } else if (type === "x-explanation") {
                y = 37;
                d3.select("#triangle-text").transition().delay(300).text("");

                triangle
                    .transition()
                    .delay(300)
                    .attr("transform", "rotate(90) translate("+y+","+-x+")")
            }

        }

        function drawHeatMap() {
            let flattened_data = [];

            for (let element of selected_subjects){
                for (let attrib of myGroups) {
                    flattened_data.push({
                        name: element.name,
                        type: attrib,
                        value: element.rating[""+attrib] || -1
                    })
                }
            };

            // update margins
            width = width_of_field * myGroups.length;
            height = height_of_field * selected_subjects.length;

            // delete labels and rectangles
            d3.selectAll('.heatmap-label')
                .remove();

            d3.selectAll('.cell').remove();

            // Build Y scales and axis:
            var y = d3.scaleBand()
                .range([ height, 0 ])
                .domain(flattened_data.map(d => {
                    return d.name
                }))
                .padding(0.0);


            // append labels
            svg.append("g")
                .attr("class","heatmap-label")
                .call(d3.axisLeft(y));

            // provide interaction on labels
            svg.selectAll(".heatmap-label text")
                .on("click", function(d) {
                    let index = selected_subjects.findIndex((subject) => (subject.name === d));
                    if (index >= 0) {
                        removeSubject(index);
                        console.log(selected_subjects);
                        drawHeatMap();
                    }
                });

            // append rect angles
            let rect = svg.selectAll("cell")
                .data(flattened_data, function (d) {
                })
                .enter()
                .append("rect")
                .attr("class", "cell")
                .attr("x", function (d) {
                    return x(d.type)
                })
                .attr("y", function (d) {
                    return y(d.name)
                })
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) {
                    if (d.value === -1) {
                        return "url(#no_rating)"
                    }
                    return ratingColorScale(d.value)
                })
                .on("mouseover", function(d) {
                    if (d.value === -1) {
                        moveTriangeToValue("x-explanation",0);
                    }else {
                        moveTriangeToValue("values",d.value/100);
                    }
            })
        }

        function drawTimeOverlapHeatmap(selected_sujects) {
            let data = generateTimeoverlapChartData(selected_sujects);
            let timeoverlapWidth = width_of_field * selected_sujects.length;
            let timeoverlapHeight = height_of_field * selected_sujects.length;

            let siblingSvg = document.getElementById('rating-map');
            let timeoverlapOffsetLeft = siblingSvg.getAttribute("width") - -margin.right;

            // Build Y scales and axis:
            let y = d3.scaleBand()
                .range([ timeoverlapHeight, 0 ])
                .domain(selected_sujects.map(d => {
                    return d.name;
                }))
                .padding(0.0);

            // Build X axis:
            var x = d3.scaleBand()
                .range([ 0, timeoverlapWidth ])
                .domain(selected_sujects.map(d => {
                    return d.name
                }))
                .padding(0.0);

            // move after rating map
            let svg = d3.select("#timeoverlap-matrix")
                .attr("width", timeoverlapWidth)
                .attr("height", timeoverlapHeight)
                .attr("transform", "translate("+(timeoverlapOffsetLeft)+", "+margin.top +")")
                .append("g");

            // show subject names on x axis
            svg.append("g")
                .attr("class", "timeoverlap-x-axis")
                .call(d3.axisTop(x))
                .selectAll("text")
                .attr("y", 0)
                .attr("x", 5)
                .attr("dy", -5)
                .attr("transform", "rotate(-45)")
                .style("text-anchor", "start");

            //append rects
            svg.append("g")
                .attr("id", "timeoverlap-content");

            let matrix = d3.select("#timeoverlap-content")
                .selectAll("rect")
                .data(data);

            matrix.enter()
                .append("rect")
                .attr("class", function(d) {
                    let classes = "cell ";
                    if (d.subjectA.name === d.subjectB.name) {
                        return classes + "overlap-identity";
                    }

                    if (d.overlaps.length === 0) {
                        return classes + "overlap-nothing";
                    } else {
                        for (let entry of d.overlaps){
                            if (entry.severity === "critical") {
                                return classes + "overlap-critical";
                            }
                        }
                        return classes + "overlap-edge";
                    }
                })
                .attr("width", width_of_field)
                .attr("height", height_of_field)
                .attr("x", function (d) {
                    return x(d['subjectB'].name)
                })
                .attr("y", function (d) {
                    return y(d['subjectA'].name)
                }).on("mouseover", function(d) {
                    drawTimeoverlapContentDetail(d)
            });
        }

        function drawTimeoverlapContentDetail(selectedOverlap) {
            console.log(selectedOverlap);
            //append all timetable entries for subjectA
            renderTimetableEnttriesForSubject(selectedOverlap.subjectA, '#subjectA')

        }

        function renderTimetableEnttriesForSubject(subject, id) {
            let data = d3.select(id)
                .html(function(d){
                    let html = `
                        <h4>${subject.name}</h4>
                        <div class='time-entries'>`;
                    for (let entry of subject.timetable) {
                        html += `
                            <div class="time-entry">
                                <div>Day: ${entry.day}</div>
                                <div>Time: ${entry.time.from} to ${entry.time.to}</div>
                                <div>Duration: ${(Object.keys(entry.duration).indexOf("from") < 0 )? entry.duration: entry.duration.from + " to " +entry.duration.to}</div>
                             </div>
                        `
                    }
                    html += "</div>";
                    return html;
                });
        }

        function createTimeoverlapContentDetail() {
            let x = document.getElementById('timeoverlap-content').getBoundingClientRect().width;

            d3.select("#timeoverlap-matrix").select("g")
                .append("g")
                .attr("transform","translate("+x+","+0+")")
                .attr("id", "overlap-content-details")
                .append("foreignObject")
                .attr("id", "subjectA");

            d3.select('#overlap-content-details')
                .append("foreignObject")
                .attr("id", "subjectB")
        }

        function drawTitles() {
            let ratingX = -margin.left/4;
            let ratingY = -20;

            let overlapWidth = document.getElementById('timeoverlap-content').getBoundingClientRect().width;
            let contentDetailWidth = 300;

            d3.select('#rating-map').select("g")
                .append("text")
                .attr("transform", "translate("+ratingX+","+ratingY+")")
                .attr("class","map-header")
                .text("Ratings");

            d3.select('#timeoverlap-matrix')
                .append("rect")
                .attr("class","map-underline")
                .attr("x",0)
                .attr("y",0)
                .attr("width", overlapWidth + contentDetailWidth)
                .attr("height", 2);
            d3.select('#timeoverlap-matrix')
                .append("text")
                .attr("transform", "translate("+overlapWidth+",0)")
                .attr("x",0)
                .attr("y", -4)
                .style("text-anchor","start")
                .attr("class","map-header")
                .text("Time overlaps")

        }

        // apply pen and zooming
        let zoom = d3.zoom()
            .on("zoom", () => {
                console.log("zoom");
                d3.select('#move-group').attr("transform", d3.event.transform)
            });
        d3.select('#heatmaps').call(zoom);

        drawHeatMap();
        drawSwsChart(selected_subjects);
        drawTimeOverlapHeatmap(selected_subjects);
        createTimeoverlapContentDetail();
        drawTitles();
        renderRemovedSubjects(removedSubjects);
    </script>
  </body>
</html>
